package sun.tools.javac;

import java.lang.reflect.*;
import java.util.*;

/** A first attempt at getting Sun's compiler to compile a file.
 * We also run the file for you if it compiles OK, else not;
 * this should be a big speedup as it avoids loading the JVM a
 * second time.
 * <P>
 * You are "not supposed" to call sun.tools.javac directly, since
 * it's not in the public API "java.*". However, it's a big convenience 
 * to be able to specify e.g., an OutputFilterStream for the output
 * (then you can e.g., tee the output).
 * <P>
 * You also are "not supposed" to put your classes into sun.*, but
 * in this case we have to because the required method initResource()
 * has default (package) visibility, and we need to call it.
 *
 * @author Ian F. Darwin, ian@darwinsys.com
 * @version $Id$
 */
public class jr extends Main {

	/** Main - just delegate to non-static methods */
	public static void main(String[] argv) {
		initResource();	// this is probably needed.
		new jr().process(argv);
	}

	/** Construct a compiler instance. */
	jr() {
		// Guess (correctly) that it takes error output file and input filename
		// Write to system.out, not system.err, for ease of redirection in
		// "glorified program loader" environments, like DOS window of MS-Win.
		super(System.out, "t.java");
	}


	/** List of all normal Compile options
	 */
	static opt[] compileOpts = {
			new opt( "-bootclasspath", true ),
			new opt( "-classpath", true ),
			new opt( "-d", true ),
			new opt( "-deprecation", false ),
			new opt( "-encoding", true ),
			new opt( "-extdirs", true ),
			new opt( "-g", false ),		// all one big long string
			new opt( "-nowarn", false ),
			new opt( "-O", false ),
			new opt( "-sourcepath", true ),
			new opt( "-target", true ),
			new opt( "-verbose", false ),
	};

	/** Return an opt that matches the string; null if not found. */
	protected opt findArg(opt[] opts, String s) {
		for (int i=0; i<opts.length; i++)
			if (s.startsWith(opts[i].option))
				return opts[i];
		return null;
	}

	/** List of "java" launcher args. 
	 * XXX we need to act upon some of these.
	 */
	static opt[] runOpts = {
		new opt("-?", false),			// print help
		new opt("-classpath", true),	// path for classes and resources
		new opt("-cp", true),			// ditto
    	new opt("-D", false),			// set a system property
		new opt("-help", false),		// print help
    	new opt("-verbose", false),		// control runtime verbosity
    	new opt("-version", false),		// print program version
		new opt("-X", false),			// help for non-standard options
	}

	/** Do the work of one jr instance. Walk through argv, putting
	 * compile args into compileArgv. First non-compiler-arg should
	 * be java source file. Args after that, if any, are run-time
	 * args, so put them into runtime Argv.
	 */
	protected void process(String argv[]) {
		Vector compileArgv = new Vector();
		String fileName = null;
		Vector runArgv = new Vector();

		// process arguments as described above.
		for (int i=0; i<argv.length; i++) {
			Debug.println("args", "ARGV[" + i + "] == " + argv[i]);
			opt thisOpt = null;
			if (fileName == null) {	// not seen filename yet
				if (argv[i].startsWith("-g") ||
					(thisOpt = findArg(compileOpts, argv[i])) != null) {
						compileArgv.addElement(argv[i]);
						if (thisOpt != null && thisOpt.takesArg)
							compileArgv.addElement(argv[1+i++]);
				} else {
					// This is it - we have a filename
					fileName = argv[i];
					compileArgv.addElement(fileName + ".java");
				}
			} else {
				// post-filename, goes into runtime argv
				runArgv.addElement(argv[i]);
			}
		}

		System.out.println("compileArgv has " + compileArgv.size());
		System.out.println("filename is " + fileName);
		System.out.println("runArgv has " + runArgv.size());

		// Try running the compiler
		if (compile((String[])compileArgv.toArray())) {
			System.out.println("Compile OK, trying to run");
			try {
				// Fetch the Class object for the just-compiled class
				// (it's probably still in memory).
				Class c = Class.forName(fileName);
				// Now clean up compiler-only stuff.
				System.gc();
				// Get a String Class Array to find main(String[] av)
				Class[] argvType = (Class[])Array.newInstance(String.class,0);
				// Now find main(String[] av)
				Method m = c.getMethod("main", argvType);
				// Hey, why not invoke it now that we've found it?
				m.invoke(null, runArgv.toArray());
			} catch (Exception e) {
				System.out.println("NOOOOOoooo! ... " + e);
			}
		} else {
			System.out.println("Compile bad, exiting");
		}
	}
}

/** Holder for one option */
class opt {
	opt(String o, boolean b) {
		option = o;
		takesArg = b;
	}
	String option;
	boolean takesArg;
}
